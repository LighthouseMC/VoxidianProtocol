use std::{collections::{BTreeMap, HashMap}, sync::LazyLock};

use serde::{Deserialize, Serialize};

use crate::value::{BlockState, Identifier};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ReportBlockState {
    pub id: Identifier,
    pub properties: BTreeMap<String, String>,

    #[serde(default = "return_false")]
    pub default: bool
}

fn return_false() -> bool {
    false
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ReportBlockStateWithMetadata {
    pub block_state: ReportBlockState,
    pub protocol_id: i32
}

impl From<ReportBlockState> for BlockState {
    fn from(value: ReportBlockState) -> Self {
        BlockState {
            id: value.id, 
            properties: value.properties
        }
    }
}

pub static BLOCK_STATE_JSON: &str = include_str!("../../generated/block_states.json");

pub static BLOCK_STATES: LazyLock<Vec<ReportBlockStateWithMetadata>> = LazyLock::new(|| {
    serde_json::from_str(BLOCK_STATE_JSON).unwrap()
});



pub static ID_TO_BLOCK_STATE: LazyLock<HashMap<i32, BlockState>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    for state in BLOCK_STATES.iter() {
        let state2 = BlockState::from(state.block_state.clone());
        map.insert(state.protocol_id, state2);
    }

    map
});

pub static BLOCK_STATE_TO_ID: LazyLock<HashMap<BlockState, i32>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    for state in BLOCK_STATES.iter() {
        map.insert(BlockState::from(state.block_state.clone()), state.protocol_id);
    }

    map
});

pub static BLOCK_STATE_DEFAULTS: LazyLock<HashMap<Identifier, BlockState>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    for state in BLOCK_STATES.iter() {
        if state.block_state.default {
            let cloned_state = BlockState::from(state.block_state.clone());
            map.insert(state.block_state.id.clone(), cloned_state);
        }
    }

    map
});

impl BlockState {
    pub fn all_block_states() -> Vec<BlockState> {
        BLOCK_STATES.iter().map(|state| BlockState::from(state.block_state.clone())).collect()
    }

    pub fn default_for(block_id: &Identifier) -> Option<BlockState> {
        BLOCK_STATE_DEFAULTS.get(block_id).cloned()
    }

    pub fn from_id(id: i32) -> Option<BlockState> {
        ID_TO_BLOCK_STATE.get(&id).cloned()
    }

    pub fn to_id(&self) -> Option<i32> {
        BLOCK_STATE_TO_ID.get(self).cloned()
    }

    pub fn to_id_mut(&mut self) -> Option<i32> {
        BLOCK_STATE_TO_ID.get(self).cloned()
    }

    pub fn add_property(&mut self, key: impl Into<String>, value: impl Into<String>) {
        self.properties.insert(key.into(), value.into());
    }
    pub fn get_property(&mut self, key: &str) -> Option<&str> {
        self.properties.get(key).map(|x| x.as_str())
    }
}

#[cfg(test)]
mod tests {

    use crate::{autogenerated::block_states::BLOCK_STATE_TO_ID, value::{BlockState, Identifier}};

    #[test]
    pub fn auto_default() {
        let state = BlockState::default_for(&Identifier::new("minecraft", "stone_brick_slab")).unwrap();
        assert!(BLOCK_STATE_TO_ID.contains_key(&state));

        let state = BlockState::default_for(&Identifier::new("minecraft", "cactus")).unwrap();
        assert!(BLOCK_STATE_TO_ID.contains_key(&state));
    }
}
