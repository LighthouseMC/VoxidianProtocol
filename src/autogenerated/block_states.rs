use std::{collections::HashMap, sync::LazyLock};

use crate::value::{BlockState, BlockStateWithMetadata, Identifier};

pub static BLOCK_STATE_JSON: &str = include_str!("../../generated/block_states.json");

pub static BLOCK_STATES: LazyLock<Vec<BlockStateWithMetadata>> = LazyLock::new(|| {
    serde_json::from_str(BLOCK_STATE_JSON).unwrap()
});



pub static ID_TO_BLOCK_STATE: LazyLock<HashMap<i32, BlockState>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    for state in BLOCK_STATES.iter() {
        let state2 = state.block_state.clone().sorted();
        map.insert(state.protocol_id, state2);
    }

    map
});

pub static BLOCK_STATE_TO_ID: LazyLock<HashMap<BlockState, i32>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    for state in BLOCK_STATES.iter() {
        map.insert(state.block_state.clone().sorted(), state.protocol_id);
    }

    map
});

pub static BLOCK_STATE_DEFAULTS: LazyLock<HashMap<Identifier, BlockState>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    for state in BLOCK_STATES.iter() {
        if !map.contains_key(&state.block_state.id)
            && !state.block_state.properties.contains(&(String::from("waterlogged"), String::from("true"))) {
            let cloned_state = state.block_state.clone();
            map.insert(state.block_state.id.clone(), cloned_state);
        }
    }

    map
});

impl BlockState {
    pub fn all_block_states() -> Vec<BlockState> {
        BLOCK_STATES.iter().map(|state| state.block_state.clone()).collect()
    }

    pub fn default_for(block_id: &Identifier) -> Option<BlockState> {
        BLOCK_STATE_DEFAULTS.get(block_id).cloned()
    }

    /// Tries to force a BlockState to be valid by removing invalid properties and adding default properties that aren't present.
    /// If the block state does not have a valid ID, this method will return Err(()).
    #[allow(clippy::result_unit_err)]
    pub fn make_valid(&mut self) -> Result<(), ()> {
        let Some(default) = BLOCK_STATE_DEFAULTS.get(&self.id).cloned() else {
            return Err(());
        };

        for property in &default.properties {
            if(!self.properties.iter().any(|x| x.0 == property.0)) {
                self.properties.push(property.clone());
            }

        }

        self.properties = self
            .properties
            .iter()
            .filter(|property| default.properties.iter().any(|x| x.0 == property.0))
            .cloned()
            .collect::<Vec<_>>();

        Ok(())
    }

    pub fn from_id(id: i32) -> Option<BlockState> {
        ID_TO_BLOCK_STATE.get(&id).cloned()
    }

    pub fn sort(&mut self) {
        self.properties.sort_by_cached_key(|x| x.0.clone());
    }

    pub fn sorted(mut self) -> Self {
        self.sort();
        self
    }

    pub fn to_id(&self) -> Option<i32> {
        let state = self.clone().sorted();
        BLOCK_STATE_TO_ID.get(&state).cloned()
    }

    pub fn to_id_mut(&mut self) -> Option<i32> {
        self.sort();
        BLOCK_STATE_TO_ID.get(self).cloned()
    }
}

#[cfg(test)]
mod tests {
    use crate::{autogenerated::block_states::BLOCK_STATE_TO_ID, value::{BlockState, Identifier}};

    #[test]
    pub fn make_valid() {
        let mut state = BlockState {
            id: Identifier::new("minecraft", "stone_brick_slab"),
            properties: Vec::new(),
        };
        state.make_valid().unwrap();
        assert!(BLOCK_STATE_TO_ID.contains_key(&state));

        let mut state = BlockState {
            id: Identifier::new("minecraft", "cactus"),
            properties: Vec::new(),
        };
        state.make_valid().unwrap();
        assert!(BLOCK_STATE_TO_ID.contains_key(&state));
    }
}
