use proc_macro2::TokenStream;

use crate::{format_token_stream, reports::get_reports_json};

pub fn make_types() {
    let json = make_types_to_json();
    let tokens = make_types_tokens(json);
    let fmt = format_token_stream(&tokens);

    std::fs::write("../src/autogenerated/block_entity_types.rs", fmt).unwrap();
}

pub(crate) fn make_types_to_json() -> Vec<(String, u32)> {
    let mut registries = get_reports_json();
    let items = registries.map.get_mut("minecraft:block_entity_type").unwrap();
    let mut vc = items.entries
        .iter()
        .map(|(name, entry)| {
            (name.clone(), entry.protocol_id)
        })
        .collect::<Vec<_>>();
    vc.sort_by_key(|x| x.1);
    vc
}

pub fn make_types_tokens(item_entries: Vec<(String, u32)>) -> TokenStream {
    let mut stream = TokenStream::new();
    let mut idx = 0;
    for entry in item_entries {
        let name = entry.0.replace("minecraft:", "");
        stream.extend(quote::quote! {
            registry.insert(Identifier::vanilla_const(#name), VarInt::new(#idx));
        });
        idx += 1;

    }
    quote::quote! {
        use crate::packet::s2c::play::ChunkBlockEntity;
use crate::packet::*;

        impl ChunkBlockEntity {
            
            #[allow(dead_code)]
            #[allow(redundant_semicolons)]
            pub fn block_entity_type_registry() -> Registry<VarInt> {
                let mut registry = Registry::new();
                #stream
                registry
            }
        }
    }
}