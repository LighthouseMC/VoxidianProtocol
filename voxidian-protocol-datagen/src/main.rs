use proc_macro2::{Ident, TokenStream};
use serde::{de::DeserializeOwned, Serialize};
use quote::{quote, ToTokens};
use voxidian_protocol::value::{Biome, DamageType};
fn main() {
    make_data_file::<DamageType>("DamageType", "../datagen/generated/data/minecraft/damage_type", "../src/autogenerated/damage_types.rs");
    make_data_file::<Biome>("Biome", "../datagen/generated/data/minecraft/worldgen/biome", "../src/autogenerated/biomes.rs");
}

fn make_data_file<T: Serialize + DeserializeOwned + ToTokens>(ty: &str, directory: &str, out_file: &str) {
    let data = generate_data::<T>(ty, directory);
    std::fs::write(out_file, data.to_string().replace("\\\"", "\"")).unwrap();
}

fn generate_data<T: Serialize + DeserializeOwned + ToTokens>(ty: &str, directory: &str) -> TokenStream {
    let ty = Ident::new(ty, proc_macro2::Span::call_site());
    let mut stream = quote! {
        let mut registry = Registry::new();
    };
    for entry in std::fs::read_dir(directory).unwrap() {

        let entry = entry.unwrap();
        let path = entry.path();
        println!("Generating data for: {:?}", path);
        let file_name = path.file_name().unwrap().to_str().unwrap().to_string().replace(".json", "");
        let file_contents = std::fs::read_to_string(path).unwrap();
        let value = serde_json::from_str::<T>(&file_contents).unwrap();

        stream.extend(quote! {
            registry.insert(Identifier::new("minecraft", #file_name), #value);
        });
    };
    quote! {
        use crate::packet::*;

        impl #ty {
            #[allow(dead_code)]
            #[allow(redundant_semicolons)]
            pub fn vanilla_registry() -> Registry<#ty> {
                #stream;
                registry
            }
        }
    }
}